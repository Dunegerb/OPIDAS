-- Migração Aprimorada para o Projeto OPIDAS
-- Adiciona campos e funcionalidades extras ao schema inicial

-- Adicionar campo de data de criação da conta (se não existir)
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS created_at timestamp with time zone default timezone('utc'::text, now()) not null;

-- Adicionar campo de última atualização
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS updated_at timestamp with time zone default timezone('utc'::text, now()) not null;

-- Adicionar campo para armazenar a data de início do onboarding
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS onboarding_date date;

-- Função para atualizar automaticamente o campo updated_at
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ language plpgsql;

-- Trigger para atualizar updated_at automaticamente
DROP TRIGGER IF EXISTS set_updated_at ON public.profiles;
CREATE TRIGGER set_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

-- Tabela para armazenar episódios da doutrina
CREATE TABLE IF NOT EXISTS public.episodes (
    id bigint generated by default as identity primary key,
    episode_number integer not null unique,
    title text not null,
    description text,
    duration_minutes integer,
    video_url text not null,
    subtitle_url text,
    thumbnail_url text,
    is_published boolean default true,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

ALTER TABLE public.episodes ENABLE ROW LEVEL SECURITY;

-- Política: Todos os usuários autenticados podem ver episódios publicados
CREATE POLICY "Authenticated users can view published episodes" ON public.episodes
    FOR SELECT USING (auth.role() = 'authenticated' AND is_published = true);

-- Tabela para histórico de resets
CREATE TABLE IF NOT EXISTS public.reset_history (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    reset_date timestamp with time zone default timezone('utc'::text, now()) not null,
    days_before_reset integer not null,
    rank_before_reset text not null
);

ALTER TABLE public.reset_history ENABLE ROW LEVEL SECURITY;

-- Política: Usuários podem ver seu próprio histórico
CREATE POLICY "Users can view their own reset history" ON public.reset_history
    FOR SELECT USING (auth.uid() = user_id);

-- Política: Usuários podem inserir seu próprio histórico
CREATE POLICY "Users can insert their own reset history" ON public.reset_history
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Tabela para logs de pagamento e webhooks do Stripe
CREATE TABLE IF NOT EXISTS public.payment_logs (
    id bigint generated by default as identity primary key,
    user_id uuid references public.profiles(id) on delete set null,
    stripe_event_id text unique,
    event_type text not null,
    status text not null,
    amount integer,
    currency text,
    metadata jsonb,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

ALTER TABLE public.payment_logs ENABLE ROW LEVEL SECURITY;

-- Política: Apenas admins podem ver logs (por enquanto sem política de select)
-- Você pode adicionar uma coluna is_admin na tabela profiles e criar a política

-- Função para calcular a patente baseada nos dias de retenção
CREATE OR REPLACE FUNCTION public.calculate_rank(days integer)
RETURNS text AS $$
BEGIN
    IF days < 10 THEN
        RETURN 'recruta';
    ELSIF days < 30 THEN
        RETURN 'soldado';
    ELSIF days < 60 THEN
        RETURN 'cabo';
    ELSIF days < 90 THEN
        RETURN 'sargento';
    ELSIF days < 180 THEN
        RETURN 'marechal';
    ELSIF days < 365 THEN
        RETURN 'tenente';
    ELSE
        RETURN 'capitao';
    END IF;
END;
$$ language plpgsql;

-- Função para atualizar dias de retenção e patente
CREATE OR REPLACE FUNCTION public.update_retention_days()
RETURNS void AS $$
DECLARE
    user_record RECORD;
    days_diff integer;
BEGIN
    FOR user_record IN 
        SELECT id, last_habit_date, retention_days 
        FROM public.profiles 
        WHERE last_habit_date IS NOT NULL
    LOOP
        -- Calcula diferença de dias entre hoje e última data de hábito
        days_diff := EXTRACT(DAY FROM (CURRENT_DATE - user_record.last_habit_date));
        
        -- Se passou mais de 1 dia, reseta a contagem
        IF days_diff > 1 THEN
            UPDATE public.profiles
            SET 
                retention_days = 0,
                rank = 'recruta',
                is_blocked = true,
                block_end_date = timezone('utc'::text, now()) + interval '7 days'
            WHERE id = user_record.id;
        END IF;
    END LOOP;
END;
$$ language plpgsql security definer;

-- Função para processar check-in diário
CREATE OR REPLACE FUNCTION public.process_daily_checkin(user_uuid uuid)
RETURNS jsonb AS $$
DECLARE
    current_profile RECORD;
    new_retention_days integer;
    new_rank text;
    days_since_last_checkin integer;
BEGIN
    -- Busca o perfil atual
    SELECT * INTO current_profile
    FROM public.profiles
    WHERE id = user_uuid;

    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'message', 'Usuário não encontrado');
    END IF;

    -- Verifica se já fez check-in hoje
    IF current_profile.last_habit_date = CURRENT_DATE THEN
        RETURN jsonb_build_object(
            'success', false, 
            'message', 'Check-in já realizado hoje',
            'retention_days', current_profile.retention_days,
            'rank', current_profile.rank
        );
    END IF;

    -- Calcula dias desde último check-in
    IF current_profile.last_habit_date IS NULL THEN
        days_since_last_checkin := 0;
    ELSE
        days_since_last_checkin := EXTRACT(DAY FROM (CURRENT_DATE - current_profile.last_habit_date));
    END IF;

    -- Se passou mais de 1 dia, reseta
    IF days_since_last_checkin > 1 THEN
        new_retention_days := 1;
    ELSE
        new_retention_days := current_profile.retention_days + 1;
    END IF;

    -- Calcula nova patente
    new_rank := public.calculate_rank(new_retention_days);

    -- Atualiza o perfil
    UPDATE public.profiles
    SET 
        last_habit_date = CURRENT_DATE,
        retention_days = new_retention_days,
        rank = new_rank
    WHERE id = user_uuid;

    RETURN jsonb_build_object(
        'success', true,
        'message', 'Check-in realizado com sucesso',
        'retention_days', new_retention_days,
        'rank', new_rank,
        'was_reset', days_since_last_checkin > 1
    );
END;
$$ language plpgsql security definer;

-- Índices para melhorar performance
CREATE INDEX IF NOT EXISTS idx_messages_channel_created ON public.messages(channel_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_messages_user ON public.messages(user_id);
CREATE INDEX IF NOT EXISTS idx_profiles_rank ON public.profiles(rank);
CREATE INDEX IF NOT EXISTS idx_profiles_subscription_status ON public.profiles(subscription_status);
CREATE INDEX IF NOT EXISTS idx_video_progress_user_episode ON public.video_progress(user_id, episode_id);

-- Comentários para documentação
COMMENT ON TABLE public.episodes IS 'Armazena os episódios de vídeo da seção Doutrina';
COMMENT ON TABLE public.reset_history IS 'Histórico de resets de contagem dos usuários';
COMMENT ON TABLE public.payment_logs IS 'Logs de eventos do Stripe para auditoria';
COMMENT ON FUNCTION public.calculate_rank IS 'Calcula a patente baseada no número de dias de retenção';
COMMENT ON FUNCTION public.update_retention_days IS 'Função para ser executada diariamente via cron job';
COMMENT ON FUNCTION public.process_daily_checkin IS 'Processa o check-in diário do usuário e atualiza sua progressão';
